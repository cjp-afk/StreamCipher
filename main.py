# This is a simple block cipher using CFB feedback to encrypt and decrypt data.
# The key and IV are generated randomly and stored in the encrypted file.
# The keystream is generated by XORing the key and IV.
# The data is encrypted by XORing the keystream with the plaintext, with each loop of the block encryption, the keystream is substituted and permeated creating the OFB (feedback loop).
# The random module is seeded with the key to generate the S-box and permutation tables.

# Imports
import os
import random


# Creating the BlockCipherOFB class
class BlockCipherOFB:

    @staticmethod
    def generate_key(block_size) -> bytes:
        """Generate a random key of block_size bytes"""
        return os.urandom(block_size)

    @staticmethod
    def generate_iv(block_size) -> bytes:
        """Generate a random IV of block_size bytes"""
        return os.urandom(block_size)

    def __init__(self, key: bytes = None, iv: bytes = None, block_size: int = 16):
        # If key and IV are not provided, generate random key and IV
        self.key = key if key is not None else self.generate_key(32)
        self.iv = iv if iv is not None else self.generate_iv(block_size)

        # We convert the key to a 256 bit integer and use it as the seed for the random module
        # We create a new random object to avoid affecting the global random state
        # This is to allow for the decryption in another session as the random outputs are deterministic from the seed
        seed = int.from_bytes(self.key, "big")
        self.rand = random.Random(seed)

        # Set the block size
        self.block_size = block_size
        self.cylces = 100

        # Generate the S-box and permutation tables
        self.sbox = self.generate_sub_tables()
        self.pattern = self.generate_perm_tables()

    def generate_sub_tables(self) -> list:
        """Generate a random S-box of 256 bytes for byte substitution"""
        sbox = list(range(256))
        self.rand.shuffle(sbox)

        return sbox

    def generate_perm_tables(self) -> list:
        """Generate a random permutation table of (block_size) bytes for block permutation"""
        pattern = list(range(self.block_size))
        self.rand.shuffle(pattern)

        return pattern

    def _keystream_loop(self, key, iv) -> bytes:
        """Generate the keystream by XORing the key and IV"""
        return bytes(key_byte ^ iv_byte for key_byte, iv_byte in zip(key, iv))

    def _substitute(self, block: bytes) -> bytes:
        """Substitute each byte in the block using the S-box"""
        return bytes([self.sbox[byte] for byte in block])

    def _permute(self, block: bytes) -> bytes:
        """Permute the block by rearranging the bytes according to the permutation table ruling"""
        return bytes([block[i] for i in self.pattern])

    def _padding(self, data: bytes) -> bytes:
        """Pad the data to be block_size bytes long"""
        padding = self.block_size - len(data) % self.block_size
        return data + bytes([padding] * padding)

    def _unpad(self, data: bytes) -> bytes:
        """Unpad the data by removing the padding"""
        padding = data[-1]
        return data[:-padding]

    def feedback(self, data: bytes) -> bytes:
        """Encrypt/Decrypt the data using the OFB mode of operation feedback loop"""
        # Initialize the output and keystream block
        output = bytearray()
        # The first keystream instance (pre XOR) is the IV
        keystream_block = self.iv

        # Multiple cycles of substitution and permutation on the plaintext block
        for _ in range(self.cylces):
            for i in range(0, len(output), self.block_size):
                block = output[i : i + self.block_size]

                block = self._substitute(block)

                block = self._permute(block)

                output[i : i + self.block_size] = block

        # Applying keystream XOR to the plaintext block
        for i in range(0, len(data), self.block_size):
            # Generate the keystream block for this loop based on previous keystream block
            encrypted_keystream_block = self._keystream_loop(self.key, keystream_block)

            # Extracting the block to be XORed
            block = data[i : i + self.block_size]

            # XORing the block with the keystream block
            # Adding the XORed block to the output
            output.extend(
                byte ^ key_byte
                for byte, key_byte in zip(block, encrypted_keystream_block)
            )

            # The keystream block to be used in the next loop is the encrypted keystream block
            keystream_block = encrypted_keystream_block

        return bytes(output)

    def encrypt(self, data: bytes) -> bytes:
        """Just because it looks nice to have a separate encrypt method"""
        return self.feedback(self._padding(data))

    def decrypt(self, data: bytes) -> bytes:
        """Same as encrypt"""
        return self._unpad(self.feedback(data))


if __name__ == "__main__":
    # Ask the user for the mode of operation
    mode = input("Enter mode (encrypt/decrypt/cli/quit): ").lower()
    while mode != "quit":
        # Encrypt the data
        if mode == "encrypt":
            file = input("Enter file name to encrypt: ")
            with open(file, "rb") as f:
                data = f.read()

            cipher = BlockCipherOFB()
            encrypted = cipher.encrypt(data)

            # Write the key, IV and encrypted data to a file
            with open("secret", "wb") as f:
                f.write(encrypted)
            with open("key", "wb") as f:
                f.write(cipher.key)
            with open("iv", "wb") as f:
                f.write(cipher.iv)

        # Decrypt the data
        elif mode == "decrypt":
            file = input("Enter file name to decrypt: ")
            with open(file, "rb") as f:
                data = f.read()
            with open("key", "rb") as f:
                key = f.read()
            with open("iv", "rb") as f:
                iv = f.read()

            cipher = BlockCipherOFB(key=key, iv=iv)
            decrypted = cipher.decrypt(data)

            # Write the decrypted data to a file
            with open("decrypted.txt", "wb") as f:
                f.write(decrypted)

        # Command line use with input
        elif mode == "cli":
            cipher = BlockCipherOFB()
            data = input("Enter data to encrypt: ").encode()

            encrypted = cipher.encrypt(data)
            print(f"Encrypted data: {encrypted}")

            decrypted = cipher.decrypt(encrypted)
            print(f"Decrypted data: {decrypted}")

        mode = input("Enter mode (encrypt/decrypt/cli/quit): ").lower()
    exit()
